---
layout: post
title: Nginx讲解
date: 2018-05-28
tags: Nginx
---

#### 大纲:
* 什么是Nginx
* 如何安装Nginx(Redhat 6.9)
* Nginx的目录结构，及其主要配置文件讲解
* Nginx如何处理一个request及配置虚拟主机
* Nginx上配置重定向
* 如何排查Application Gateway为502的问题

#### 目的：
* 当AppGw的后端为开源的web服务器时，如何排查AppGw的502问题？

#### 预备知识:
* **vim**: 高效的linux文本编辑器，类似于windows下的notepad或notepad++. 参考学习文档：[vim 程序编辑器](http://cn.linux.vbird.org/linux_basic/0310vi.php)
* **cat**: Linux系统中最常用的命令之一，主要用来查看文件的内容，类似于windows下的notepad. 比如:
 
    ```
    # 打印/etc/resolv.conf文件的所有内容
	[root@srv-lambert-centos-test1 ~]# cat /etc/resolv.conf
	; generated by /sbin/dhclient-script
	search e3n5edmlpdcebhrj2vb0sww3yf.ix.internal.cloudapp.net
	nameserver 168.63.129.16
	 ```
 
* **tail**: Linux系统中最常用的命令之一，主要作用是查看文件内容，不同于cat的是，默认情况下tail只显示最后10行的内容，当然tail支持其他的参数，比如:

    ```
    # 实时显示/var/log/access.log文件的内容
	[root@srv-lambert-centos-test1 ~]# tail -f /var/log/access.log 
	10.0.2.5 - - [13/Feb/2018:14:14:24 +0800] "GET / HTTP/1.1" 200 6 "-" "-"
	10.0.2.4 - - [13/Feb/2018:14:14:38 +0800] "GET / HTTP/1.1" 200 6 "-" "-"
	10.0.2.4 - - [13/Feb/2018:14:14:38 +0800] "GET / HTTP/1.1" 200 6 "-" "-"
	10.0.2.4 - - [13/Feb/2018:14:14:39 +0800] "GET / HTTP/1.1" 200 6 "-" "-"
	10.0.2.5 - - [13/Feb/2018:14:14:54 +0800] "GET / HTTP/1.1" 200 6 "-" "-"
	
	```
* **grep**: 用来过滤文件中的内容。类似于windows下的findstr。 比如：

   ```
	# 从网站访问日志过滤包含404的请求
	[root@srv-lambert-centos-test1 ~]# cat /var/log/nginx/access.log | grep 404
	13.66.211.164 - - [28/May/2018:04:26:14 +0800] "GET /flumemaster.jsp HTTP/1.1" 404 3652 "-" "Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)" "-"
	13.66.211.164 - - [28/May/2018:04:26:14 +0800] "GET /rs-status HTTP/1.1" 404 3652 "-" "Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)" "-"
	13.66.211.164 - - [28/May/2018:04:26:14 +0800] "GET /nmaplowercheck1527452816 HTTP/1.1" 404 3652 "-" "Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)" "-"
   ```
 * **yum**: Redhat/CentOS系统软件包管理工具. 常用操作：

   ```
   1. 安装telnet工具
	 [root@srv-lambert-centos-test1 ~]# yum install telnet
   2. 删除telnet工具
	 [root@srv-lambert-centos-test1 ~]# yum remove telnet
	3. 更新telnet工具
     [root@srv-lambert-centos-test1 ~]# yum update telnet
   ```
   
* **apt-get**: Ubuntu系统软件包管理工具. 

   ```
   1. 安装telnet工具
	 [root@srv-lambert-ubuntu-test1 ~]# apt-get install telnet
   2. 删除telnet工具
	 [root@srv-lambert-ubuntu-test1 ~]# apt-get remove telnet
	3. 更新telnet工具
     [root@srv-lambert-ubuntu-test1 ~]# apt-get update telnet
   ``` 
 
#### 什么是Nginx?
* 是一个异步框架的Web服务器. 该软件由Igor Sysoev(Russian)创建，并于2004年首次公开发布。
* 可以用作反向代理，代理php,python,java等程序。
* 负载平衡器，可以配置成基于四层或七层的负载转发。
* HTTP静态缓存服务器，用于响应用户的静态请求。众所周知的CDN。
* 解决了C10k问题。
* 支持添加[模块](https://www.nginx.com/resources/wiki/modules/)
* 开源软件，根据类BSD许可证的条款发布.
* 截至2018年1月，Nginx 服务或者代理了全球 30.46% 的网站

#### 如何安装Nginx：

 > 通过源码编译安装。不做介绍,感兴趣请参考: [Nginx安装方式](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)
 
 > 通过编译后的软件包安装.

1. 配置官方安装仓库，**注意**：我的系统是基于Redhat 6.9，请通过 "cat /etc/redhat-release" 查看系统版本，然后替换掉baseurl的OS，如果是Redhat，那么值为rhel，如果是CentOS，那么值为centos。 baseurl中的Release是操作系统的主版本。


	```
	[root@srv-lambert-centos-test1 ~]# cat /etc/redhat-release
	Red Hat Enterprise Linux Server release 6.9 (Santiago)
	[root@srv-lambert-centos-test1 ~]# cat << 'EOF' >> /etc/yum.repos.d/nginx.repo
	[nginx]
	name=nginx repo
	#baseurl=https://nginx.org/packages/mainline/<OS>/<Release>/$basearch/
	baseurl=https://nginx.org/packages/mainline/rhel/6/$basearch/
	gpgcheck=0
	enabled=1
	EOF
	 ```
2. 安装Nginx
	
	```
	[root@srv-lambert-centos-test1 ~]# yum install nginx -y
	```
	
3. 启动Nginx服务
  
   ```
   [root@srv-lambert-centos-test1 ~]# /etc/init.d/nginx start
	Starting nginx:                                            [  OK  ]
	```

4. 查看Nginx的进程

```
[root@srv-lambert-centos-test1 ~]# netstat -nlpt | grep nginx
tcp        0      0 0.0.0.0:80                  0.0.0.0:*                   LISTEN      73392/nginx
[root@srv-lambert-centos-test1 ~]# ps aux | grep nginx
root      73392  0.0  0.1  47324  1100 ?        Ss   15:48   0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf
nginx     73393  0.0  0.1  47840  1832 ?        S    15:48   0:00 nginx: worker process
```

#### Nginx的目录结构
1. 查看Nginx的目录结构

	```
	[root@srv-lambert-centos-test1 ~]# tree /etc/nginx
	/etc/nginx
	|-- conf.d  # 有经验的工程师会将自己的虚拟主机定义在conf.d中，便于管理
	|   `-- default.conf # 安装好之后有个默认的虚拟主机文件
	|-- fastcgi_params #在做配置fastcgi代理时，会include这个文件，然后nginx会修改对应变量的值，将其和请求一块传递到后端的FastCGI服务器。
	|-- koi-utf
	|-- koi-win
	|-- mime.types   # 将文件名映射为响应的内容类型，这样浏览器都可以根据内容类型去做渲染。
	|-- modules -> ../../usr/lib64/nginx/modules
	|-- nginx.conf   #主配置文件，整个nginx的入口，加载Nginx的主配置文件， 虚拟主机中。
	|-- scgi_params
	|-- uwsgi_params #在配置uwsgi反向代理的时候，会将文件内定义的参数传递给后端的uwsgi服务器。
	`-- win-utf
	
	2 directories, 9 files
	```
2. Nginx的主配置文件, 主要有两部分组成
   > Simple Directive： 其配置参数只有一行。
  
   > Block directives: 由一组参数包括在{}中。

   ```
   [root@srv-lambert-centos-test1 modules]# cat /etc/nginx/nginx.conf

	user  nginx;
	worker_processes  1;
	
	error_log  /var/log/nginx/error.log warn;
	pid        /var/run/nginx.pid;
	
	
	events {
	    worker_connections  1024;
	}
	
	
	http {  #全局配置部分，server{}如果不重写，则集成
	   include       /etc/nginx/mime.types;
	    default_type  application/octet-stream;
	
	    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
	                      '$status $body_bytes_sent "$http_referer" '
	                      '"$http_user_agent" "$http_x_forwarded_for"';   # 日志格式；
	
	    access_log  /var/log/nginx/access.log  main;   #默认的网站访问日志；
	
	    sendfile        on;
	    #tcp_nopush     on;
	
	    keepalive_timeout  65;  #跟客户端保持的长链接时长；
	
	    #gzip  on;
	
	    include /etc/nginx/conf.d/*.conf;  # 用来告知Nginx服务，要加载所有以conf结尾的文件，作为nginx.conf的一部分。主要用来配置多个虚拟主机。
	}
   ```

#### Nginx如何处理一个request及配置虚拟主机

##### 目前来说由三种方式配置虚拟主机

> 1. 基于域名, 现代的做法.
> 2. 基于IP地址, 由于Ipv4资源不足和资金问题，基本上不咋用。
> 3. 基于端口，用于用户来说体验不好，基本上不咋用。

 
1. Nginx处理请求流程:
   1. nginx首先根据请求头部的host字段决定由哪一个虚拟主机处理对应的请求。
   2. 如果对应的host值没有匹配到合适的虚拟主机，nginx则路由这个请求到默认的主机。
   3. nginx根据对应虚拟主机配置文件中的定义，顺序匹配server块中break, if, return, rewrite, 和set语句。
   4. 然后匹配location(如果有多个location，则重复匹配)，匹配最长前缀location，然后再找正则表达式匹配，如果匹配到正则表达式，则匹配完成，直接处理请求，如果匹配不到正则表达式，那么按照最长前缀location匹配处理请求。如果有"=", 则为精确匹配，请求则匹配“=”，停止其它匹配，直接处理请求。
   5. 

   
2. 创建一个自定义的virtual host叫做lambert.com.

	```
	[root@srv-lambert-centos-test1 images]# cat /etc/nginx/conf.d/lambert.com.conf
	  server {
	          server_name     lambert.com www.lambert.com;     #虚拟主机名
	          root /var/www/sites/lambert.com;  #网站根目录
	          access_log   /var/log/nginx/lambert.com/access_lambert-check.log  main;  #定义网站的访问日志文件位置
	          error_log   /var/log/nginx/lambert.com/error_lambert-check.log;   #定义网站访问错误的日志文件位置
	
	          location / {
	            index index.html;
	          }
	
	          location = / {
	            index index.html;
	          }
	
	         location ^~ /images/ {
	            expires 1d;
	          }
	
	         location ~*  \.(jpg|jpeg|png|gif|ico|css|js)$ {
	            expires 365d;
	         }
	
	         location /documents/ {
	           index doc.html;
	         }
	
	
	         location ~ \.php$ {
	            fastcgi_pass   127.0.0.1:9000;
	            #fastcgi_pass   unix:/tmp/php-fpm.sock;
	            fastcgi_index  index.php;
	            #fastcgi_buffer_size 128k;
	            #fastcgi_buffers 64 256k;
	            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
	            include        fastcgi_params;
	
	         }
	
	  }
	```

  需要注意的是：

  > 1. 通过location用来匹配用户的访问内容，location的条件可以被定义为前缀匹配或正则表达式匹配，正则表达式匹配通过“~*”(不区分大小写)或“~”(区分大小写). 为了完成请求的匹配，nginx首先会检查基于前缀的location, 如果有多个，则选择最长匹配。然后按照配置文件中的定义，顺序检查基于正则表达式的location,如果找到，则停止匹配，直接返回。如果没有找到，则匹配最长的前缀匹配。
	 
  > 2. 如果最长前缀匹配有“^~”，则跳过正则表达式匹配。
	 
  > 3. 如果使用“=”， 那么意思就是精确匹配，如果请求匹配，匹配停止
  
3. 重启Nginx，加载虚拟主机。

	```
	[root@srv-lambert-centos-test1 conf.d]# /etc/init.d/nginx restart
	Stopping nginx:                                            [  OK  ]
	Starting nginx:                                            [  OK  ]
	```
	
#### Nginx上配置重定向
###### 可以通过rewrite和return处理none-www到www的请求，或http到https的重定向请求。但是return的效率相对来说比较高，因为return通过内置变量直接返回，而rewrite需要匹配请求的url。

```
## Redirect from non-www to www
server {
    server_name lambert.com www.lambert.com;
    if ($host !~* ^www\.){
        #Option 1. - good
        #rewrite ^(.*)$ http://www.lambert.com$1  permanent;
        #Option 2. - better
        return 301 http://www.lambert.com$request_uri;
     }
}

## Redirect from http to https
server {
    server_name lambert.com www.lambert.com;
    if ($scheme = http) {
       #Option 1. - good
       rewrite ^(.*)$ https://www.lambert.com$1  permanent;
       #Option 2. - better
       #return  301 https://$http_host$request_uri;
    }
}
```

#### AppGw 502问题的troubleshooting
1. 首先，在什么情况下AppGw会返回502？
   1. 后端所有主机健康检查不通过，AppGw直接返回502。(95%)
   2. 如果后端只有一台主机，健康检查通过，但是客户端收到502。(2%)
   3. 如果后端有多台主机(>=2), 健康检查都通过，但是客户端有时会收到502，有时正常。(2%)

2. 在什么情况下， AppGw会将后端标记为healthy状态。
   默认情况下，如果后端返回的http状态码是200˜399。那么则认为后端健康检查正常。

3. 当AppGw后端为nginx服务器时，我是如何解决502问题？
   1. 首先检查AppGw的配置，弄清楚客户的逻辑流量走向。
   2. 通过Orb或Jarvis检查AppGw的health-checklog，看后端的健康检查是unhealthy还是healthy的。
   3. 如果后端是unhealthy，并且使用的是SSL Offload或HTTP模式。检查AppGw的probe。如果客户使用默认的probe，那么Appgw会通过http://127.0.0.1:<port>/进行后端健康检查，那么你可以登陆到客户的服务器，做"curl http://127.0.0.1:<port> -I", 如果返回的http状态码是4xx或5xx。那你可以帮助客户修复问题或engage客户去做修复操作。如果客户使用的是自定义的probe，比如probe定义的host为www.lambert.com或127.0.0.1, path为/health.html，则在后端机器上做"curl http://www.lambert.com:<port>/health.html -I"，
      > 这里请注意：我曾碰到客户在AppGw托管多个主机，举个例子客户通过在listener上配置www.lambert.com，然后后端主机也配置的是www.lambert.com，然后客户将www.lambert.com的DNS解析在AppGw上，这种情况下就会产生loop。健康检查就永远不会成功，因此建议先在客户的后端机器上做个nslookup。
   
	   ```
	   [root@srv-lambert-centos-test1 conf.d]# curl http://127.0.0.1:80 -I
		HTTP/1.1 200 OK
		Server: nginx/1.13.12
		Date: Mon, 28 May 2018 12:27:30 GMT
		Content-Type: text/html
		Content-Length: 612
		Last-Modified: Tue, 10 Apr 2018 14:25:21 GMT
		Connection: keep-alive
		ETag: "5accc951-264"
		Accept-Ranges: bytes
		
			
	   ```
  4. 如果后端是unhealthy，并且使用的是end-to-end SSL， 还是检查客户配置的probe，如果是默认的probe,AppGw则使用https://127.0.0.1:<port>/对后端进行探测。如果客户使用的是自定义的probe，比如probe host为127.0.0.1, path为/health.html. 证书为www.lambert.com， 那打死AppGw，AppGw的健康检查也不会通过。
     
     ```
     [root@srv-lambert-centos-test1 conf.d]# curl https://127.0.0.1 -I
	  curl: (7) couldn't connect to host
     ```

